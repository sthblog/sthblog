<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NodeJs笔记]]></title>
    <url>%2F2018%2F07%2F15%2F%E4%B8%80%E4%B8%AA%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[说明书其实很久很久以前就想要有一个自己的博文网站，只是耐于自己心态浮躁了，一直没好好的做，当然这不只是一个程序员的博客网站，我希望的是可以分享我一些觉得可以分享的东西，也算是自己的一个墓志铭=。=，我在说啥我也不知道~]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>说明书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs笔记]]></title>
    <url>%2F2018%2F07%2F14%2FNodeJS%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[NodeJS笔记HTTP模块1234567891011//http模块var http=require('http');http.createServer(function (req,rsp) &#123;//协议头配置rsp.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;);//网页输出rsp.write('网页内容编写&lt;/br&gt;');rsp.end("网页结束");&#125;).listen(80);//设置监听端口：80//控制台输出console.log('控制台输出'); URL模块12345678910111213141516171819202122232425//http模块var http=require('http');//url模块var url=require('url');http.createServer(function (req,rsp) &#123;//协议头配置rsp.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;);//网页输出rsp.end("网页输出");if(req.url!='/favicon.ico')&#123;//获取url req.urlconsole.log('url:'+req.url);//url地址分析 模块化 第二个参数为true时，自动将url中的参数转为对象var result=url.parse(req.url,true);//对解析的urlconsole.log('result:',result);//对解析过得url进行重新整理成urlconsole.log('url.format:'+url.format(result));//如果参数中带有aid可以直接指向对象console.log('aid:'+result.query.aid);&#125;&#125;).listen(80);//listen()对端口进行设置//控制台输出var a=1;console.log('控制台%d',a); NodeJs自定义模块##FS文件操作模块 stat检查目录或文件是否存在12345678910111213var fs =require('fs');//检查目录或文件是否存在（参数1回调错误，参数2文件数据）fs.stat('1.txt',function (error,stars) &#123; if(error)&#123; console.log(error); return &#125; if(stars)&#123; console.log(stars); console.log('检查是否为文件',stars.isFile()); console.log('检查是否为文件夹',stars.isDirectory()); &#125;&#125;); 创建目录、删除目录，创建文件，删除文件模块123456789101112131415161718192021222324252627//创建目录（mkdir）、删除目录（rmdir），创建文件（writeFile），删除文件（unlink）var fs =require('fs');fs.mkdir('logs',function (error) &#123; if(error) &#123; console.log(error); return false &#125; console.log('创建目录成功'); fs.writeFile('logs/1.txt',"文件","utf8",function (err) &#123; if(err)&#123; console.log(err); &#125; console.log("创建文件成功"); fs.unlink("logs/1.txt",function (err) &#123; if(err)&#123; console.log(err); &#125; console.log("删除文件成功"); fs.rmdir("logs",function (error) &#123; if(error)&#123; console.log(error); &#125; console.log("删除目录成功"); &#125;); &#125;); &#125;);&#125;); 文件流操作12345678910111213141516171819var fs=require("fs");//创建读文件文件流var readSteam=fs.createReadStream('./1.txt',"utf8");//创建写文件文件流var writeSteam=fs.createWriteStream("./2.txt");//读文件函数readSteam.on("data",function (data) &#123; //读过程将数据写入 writeSteam.write(data,"utf8"); //标记文件结尾 writeSteam.end(); // 处理流事件 --&gt; finish 事件 writeSteam.on('finish',function () &#123; console.log("写入完成"); &#125;); writeSteam.on('error',function (error) &#123; console.log("错误"); &#125;);&#125;); 管道流操作 如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。 1234var fs =require('fs');var readSteam=fs.createReadStream('./1.txt',"utf8");var writeSteam=fs.createWriteStream("./2.txt");readSteam.pipe(writeSteam); The first project1234567891011121314151617181920212223242526272829303132333435363738//http模块var http=require('http');//fs模块var fs=require('fs');//url模块var url=require("url");//自定义模块（设置文件格式）var model=require("./model/getmime.js");//path模块var path=require('path');http.createServer(function (request,respose) &#123; //创建Web服务 respose.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); //通过url获取url文件路径 var urlName=url.parse(request.url).pathname; if(urlName!='/favicon.ico')&#123;if(urlName=='/')&#123; urlName="/index.html";&#125; var extname=path.extname(urlName); //console.log(urlName); fs.readFile('./static/'+urlName,function (err,date) &#123;if(err)&#123; fs.readFile('./static/404.html',function (error,date404) &#123; respose.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); //console.log(date.toString()); respose.write(date404); respose.end(); &#125;);return&#125;else &#123; var nime=model.getMime(extname); respose.writeHead(200,&#123;"Content-Type":""+nime+";charset='utf-8'"&#125;); respose.write(date); respose.end();&#125;&#125;);&#125;&#125;).listen(80); 1234567891011121314151617181920exports.getMime=function(extname)&#123; switch (extname)&#123; case '.html': return 'text/html'; case '.css': return 'text/css'; case '.js': return 'text/javascript'; default: return 'text/html'; &#125;&#125; 对fist project的一些修改12345678910/*为了适应更多的格式文件将读取文件类型从mime.json文件中读取*/exports.getMime=function(fs,extname)&#123; /*获取后缀名的方法*/ //把读取数据改成同步 var data=fs.readFileSync('./mime.json'); //data.toString() 转换成json字符串 var Mimes=JSON.parse(data.toString()); /*把json字符串转换成json对象*/ return Mimes[extname] || 'text/html';&#125; 文件&lt;mine.json&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484&#123; ".323":"text/h323" , ".3gp":"video/3gpp" , ".aab":"application/x-authoware-bin" , ".aam":"application/x-authoware-map" , ".aas":"application/x-authoware-seg" , ".acx":"application/internet-property-stream" , ".ai":"application/postscript" , ".aif":"audio/x-aiff" , ".aifc":"audio/x-aiff" , ".aiff":"audio/x-aiff" , ".als":"audio/X-Alpha5" , ".amc":"application/x-mpeg" , ".ani":"application/octet-stream" , ".apk":"application/vnd.android.package-archive" , ".asc":"text/plain" , ".asd":"application/astound" , ".asf":"video/x-ms-asf" , ".asn":"application/astound" , ".asp":"application/x-asap" , ".asr":"video/x-ms-asf" , ".asx":"video/x-ms-asf" , ".au":"audio/basic" , ".avb":"application/octet-stream" , ".avi":"video/x-msvideo" , ".awb":"audio/amr-wb" , ".axs":"application/olescript" , ".bas":"text/plain" , ".bcpio":"application/x-bcpio" , ".bin ":"application/octet-stream" , ".bld":"application/bld" , ".bld2":"application/bld2" , ".bmp":"image/bmp" , ".bpk":"application/octet-stream" , ".bz2":"application/x-bzip2" , ".c":"text/plain" , ".cal":"image/x-cals" , ".cat":"application/vnd.ms-pkiseccat" , ".ccn":"application/x-cnc" , ".cco":"application/x-cocoa" , ".cdf":"application/x-cdf" , ".cer":"application/x-x509-ca-cert" , ".cgi":"magnus-internal/cgi" , ".chat":"application/x-chat" , ".class":"application/octet-stream" , ".clp":"application/x-msclip" , ".cmx":"image/x-cmx" , ".co":"application/x-cult3d-object" , ".cod":"image/cis-cod" , ".conf":"text/plain" , ".cpio":"application/x-cpio" , ".cpp":"text/plain" , ".cpt":"application/mac-compactpro" , ".crd":"application/x-mscardfile" , ".crl":"application/pkix-crl" , ".crt":"application/x-x509-ca-cert" , ".csh":"application/x-csh" , ".csm":"chemical/x-csml" , ".csml":"chemical/x-csml" , ".css":"text/css" , ".cur":"application/octet-stream" , ".dcm":"x-lml/x-evm" , ".dcr":"application/x-director" , ".dcx":"image/x-dcx" , ".der":"application/x-x509-ca-cert" , ".dhtml":"text/html" , ".dir":"application/x-director" , ".dll":"application/x-msdownload" , ".dmg":"application/octet-stream" , ".dms":"application/octet-stream" , ".doc":"application/msword" , ".docx":"application/vnd.openxmlformats-officedocument.wordprocessingml.document" , ".dot":"application/msword" , ".dvi":"application/x-dvi" , ".dwf":"drawing/x-dwf" , ".dwg":"application/x-autocad" , ".dxf":"application/x-autocad" , ".dxr":"application/x-director" , ".ebk":"application/x-expandedbook" , ".emb":"chemical/x-embl-dl-nucleotide" , ".embl":"chemical/x-embl-dl-nucleotide" , ".eps":"application/postscript" , ".epub":"application/epub+zip" , ".eri":"image/x-eri" , ".es":"audio/echospeech" , ".esl":"audio/echospeech" , ".etc":"application/x-earthtime" , ".etx":"text/x-setext" , ".evm":"x-lml/x-evm" , ".evy":"application/envoy" , ".exe":"application/octet-stream" , ".fh4":"image/x-freehand" , ".fh5":"image/x-freehand" , ".fhc":"image/x-freehand" , ".fif":"application/fractals" , ".flr":"x-world/x-vrml" , ".flv":"flv-application/octet-stream" , ".fm":"application/x-maker" , ".fpx":"image/x-fpx" , ".fvi":"video/isivideo" , ".gau":"chemical/x-gaussian-input" , ".gca":"application/x-gca-compressed" , ".gdb":"x-lml/x-gdb" , ".gif":"image/gif" , ".gps":"application/x-gps" , ".gtar":"application/x-gtar" , ".gz":"application/x-gzip" , ".h":"text/plain" , ".hdf":"application/x-hdf" , ".hdm":"text/x-hdml" , ".hdml":"text/x-hdml" , ".hlp":"application/winhlp" , ".hqx":"application/mac-binhex40" , ".hta":"application/hta" , ".htc":"text/x-component" , ".htm":"text/html" , ".html":"text/html" , ".hts":"text/html" , ".htt":"text/webviewhtml" , ".ice":"x-conference/x-cooltalk" , ".ico":"image/x-icon" , ".ief":"image/ief" , ".ifm":"image/gif" , ".ifs":"image/ifs" , ".iii":"application/x-iphone" , ".imy":"audio/melody" , ".ins":"application/x-internet-signup" , ".ips":"application/x-ipscript" , ".ipx":"application/x-ipix" , ".isp":"application/x-internet-signup" , ".it":"audio/x-mod" , ".itz":"audio/x-mod" , ".ivr":"i-world/i-vrml" , ".j2k":"image/j2k" , ".jad":"text/vnd.sun.j2me.app-descriptor" , ".jam":"application/x-jam" , ".jar":"application/java-archive" , ".java":"text/plain" , ".jfif":"image/pipeg" , ".jnlp":"application/x-java-jnlp-file" , ".jpe":"image/jpeg" , ".jpeg":"image/jpeg" , ".jpg":"image/jpeg" , ".jpz":"image/jpeg" , ".js":"application/x-javascript" , ".jwc":"application/jwc" , ".kjx":"application/x-kjx" , ".lak":"x-lml/x-lak" , ".latex":"application/x-latex" , ".lcc":"application/fastman" , ".lcl":"application/x-digitalloca" , ".lcr":"application/x-digitalloca" , ".lgh":"application/lgh" , ".lha":"application/octet-stream" , ".lml":"x-lml/x-lml" , ".lmlpack":"x-lml/x-lmlpack" , ".log":"text/plain" , ".lsf":"video/x-la-asf" , ".lsx":"video/x-la-asf" , ".lzh":"application/octet-stream" , ".m13":"application/x-msmediaview" , ".m14":"application/x-msmediaview" , ".m15":"audio/x-mod" , ".m3u":"audio/x-mpegurl" , ".m3url":"audio/x-mpegurl" , ".m4a":"audio/mp4a-latm" , ".m4b":"audio/mp4a-latm" , ".m4p":"audio/mp4a-latm" , ".m4u":"video/vnd.mpegurl" , ".m4v":"video/x-m4v" , ".ma1":"audio/ma1" , ".ma2":"audio/ma2" , ".ma3":"audio/ma3" , ".ma5":"audio/ma5" , ".man":"application/x-troff-man" , ".map":"magnus-internal/imagemap" , ".mbd":"application/mbedlet" , ".mct":"application/x-mascot" , ".mdb":"application/x-msaccess" , ".mdz":"audio/x-mod" , ".me":"application/x-troff-me" , ".mel":"text/x-vmel" , ".mht":"message/rfc822" , ".mhtml":"message/rfc822" , ".mi":"application/x-mif" , ".mid":"audio/mid" , ".midi":"audio/midi" , ".mif":"application/x-mif" , ".mil":"image/x-cals" , ".mio":"audio/x-mio" , ".mmf":"application/x-skt-lbs" , ".mng":"video/x-mng" , ".mny":"application/x-msmoney" , ".moc":"application/x-mocha" , ".mocha":"application/x-mocha" , ".mod":"audio/x-mod" , ".mof":"application/x-yumekara" , ".mol":"chemical/x-mdl-molfile" , ".mop":"chemical/x-mopac-input" , ".mov":"video/quicktime" , ".movie":"video/x-sgi-movie" , ".mp2":"video/mpeg" , ".mp3":"audio/mpeg" , ".mp4":"video/mp4" , ".mpa":"video/mpeg" , ".mpc":"application/vnd.mpohun.certificate" , ".mpe":"video/mpeg" , ".mpeg":"video/mpeg" , ".mpg":"video/mpeg" , ".mpg4":"video/mp4" , ".mpga":"audio/mpeg" , ".mpn":"application/vnd.mophun.application" , ".mpp":"application/vnd.ms-project" , ".mps":"application/x-mapserver" , ".mpv2":"video/mpeg" , ".mrl":"text/x-mrml" , ".mrm":"application/x-mrm" , ".ms":"application/x-troff-ms" , ".msg":"application/vnd.ms-outlook" , ".mts":"application/metastream" , ".mtx":"application/metastream" , ".mtz":"application/metastream" , ".mvb":"application/x-msmediaview" , ".mzv":"application/metastream" , ".nar":"application/zip" , ".nbmp":"image/nbmp" , ".nc":"application/x-netcdf" , ".ndb":"x-lml/x-ndb" , ".ndwn":"application/ndwn" , ".nif":"application/x-nif" , ".nmz":"application/x-scream" , ".nokia-op-logo":"image/vnd.nok-oplogo-color" , ".npx":"application/x-netfpx" , ".nsnd":"audio/nsnd" , ".nva":"application/x-neva1" , ".nws":"message/rfc822" , ".oda":"application/oda" , ".ogg":"audio/ogg" , ".oom":"application/x-AtlasMate-Plugin" , ".p10":"application/pkcs10" , ".p12":"application/x-pkcs12" , ".p7b":"application/x-pkcs7-certificates" , ".p7c":"application/x-pkcs7-mime" , ".p7m":"application/x-pkcs7-mime" , ".p7r":"application/x-pkcs7-certreqresp" , ".p7s":"application/x-pkcs7-signature" , ".pac":"audio/x-pac" , ".pae":"audio/x-epac" , ".pan":"application/x-pan" , ".pbm":"image/x-portable-bitmap" , ".pcx":"image/x-pcx" , ".pda":"image/x-pda" , ".pdb":"chemical/x-pdb" , ".pdf":"application/pdf" , ".pfr":"application/font-tdpfr" , ".pfx":"application/x-pkcs12" , ".pgm":"image/x-portable-graymap" , ".pict":"image/x-pict" , ".pko":"application/ynd.ms-pkipko" , ".pm":"application/x-perl" , ".pma":"application/x-perfmon" , ".pmc":"application/x-perfmon" , ".pmd":"application/x-pmd" , ".pml":"application/x-perfmon" , ".pmr":"application/x-perfmon" , ".pmw":"application/x-perfmon" , ".png":"image/png" , ".pnm":"image/x-portable-anymap" , ".pnz":"image/png" , ".pot,":"application/vnd.ms-powerpoint" , ".ppm":"image/x-portable-pixmap" , ".pps":"application/vnd.ms-powerpoint" , ".ppt":"application/vnd.ms-powerpoint" , ".pptx":"application/vnd.openxmlformats-officedocument.presentationml.presentation" , ".pqf":"application/x-cprplayer" , ".pqi":"application/cprplayer" , ".prc":"application/x-prc" , ".prf":"application/pics-rules" , ".prop":"text/plain" , ".proxy":"application/x-ns-proxy-autoconfig" , ".ps":"application/postscript" , ".ptlk":"application/listenup" , ".pub":"application/x-mspublisher" , ".pvx":"video/x-pv-pvx" , ".qcp":"audio/vnd.qcelp" , ".qt":"video/quicktime" , ".qti":"image/x-quicktime" , ".qtif":"image/x-quicktime" , ".r3t":"text/vnd.rn-realtext3d" , ".ra":"audio/x-pn-realaudio" , ".ram":"audio/x-pn-realaudio" , ".rar":"application/octet-stream" , ".ras":"image/x-cmu-raster" , ".rc":"text/plain" , ".rdf":"application/rdf+xml" , ".rf":"image/vnd.rn-realflash" , ".rgb":"image/x-rgb" , ".rlf":"application/x-richlink" , ".rm":"audio/x-pn-realaudio" , ".rmf":"audio/x-rmf" , ".rmi":"audio/mid" , ".rmm":"audio/x-pn-realaudio" , ".rmvb":"audio/x-pn-realaudio" , ".rnx":"application/vnd.rn-realplayer" , ".roff":"application/x-troff" , ".rp":"image/vnd.rn-realpix" , ".rpm":"audio/x-pn-realaudio-plugin" , ".rt":"text/vnd.rn-realtext" , ".rte":"x-lml/x-gps" , ".rtf":"application/rtf" , ".rtg":"application/metastream" , ".rtx":"text/richtext" , ".rv":"video/vnd.rn-realvideo" , ".rwc":"application/x-rogerwilco" , ".s3m":"audio/x-mod" , ".s3z":"audio/x-mod" , ".sca":"application/x-supercard" , ".scd":"application/x-msschedule" , ".sct":"text/scriptlet" , ".sdf":"application/e-score" , ".sea":"application/x-stuffit" , ".setpay":"application/set-payment-initiation" , ".setreg":"application/set-registration-initiation" , ".sgm":"text/x-sgml" , ".sgml":"text/x-sgml" , ".sh":"application/x-sh" , ".shar":"application/x-shar" , ".shtml":"magnus-internal/parsed-html" , ".shw":"application/presentations" , ".si6":"image/si6" , ".si7":"image/vnd.stiwap.sis" , ".si9":"image/vnd.lgtwap.sis" , ".sis":"application/vnd.symbian.install" , ".sit":"application/x-stuffit" , ".skd":"application/x-Koan" , ".skm":"application/x-Koan" , ".skp":"application/x-Koan" , ".skt":"application/x-Koan" , ".slc":"application/x-salsa" , ".smd":"audio/x-smd" , ".smi":"application/smil" , ".smil":"application/smil" , ".smp":"application/studiom" , ".smz":"audio/x-smd" , ".snd":"audio/basic" , ".spc":"application/x-pkcs7-certificates" , ".spl":"application/futuresplash" , ".spr":"application/x-sprite" , ".sprite":"application/x-sprite" , ".sdp":"application/sdp" , ".spt":"application/x-spt" , ".src":"application/x-wais-source" , ".sst":"application/vnd.ms-pkicertstore" , ".stk":"application/hyperstudio" , ".stl":"application/vnd.ms-pkistl" , ".stm":"text/html" , ".svg":"image/svg+xml" , ".sv4cpio":"application/x-sv4cpio" , ".sv4crc":"application/x-sv4crc" , ".svf":"image/vnd" , ".svg":"image/svg+xml" , ".svh":"image/svh" , ".svr":"x-world/x-svr" , ".swf":"application/x-shockwave-flash" , ".swfl":"application/x-shockwave-flash" , ".t":"application/x-troff" , ".tad":"application/octet-stream" , ".talk":"text/x-speech" , ".tar":"application/x-tar" , ".taz":"application/x-tar" , ".tbp":"application/x-timbuktu" , ".tbt":"application/x-timbuktu" , ".tcl":"application/x-tcl" , ".tex":"application/x-tex" , ".texi":"application/x-texinfo" , ".texinfo":"application/x-texinfo" , ".tgz":"application/x-compressed" , ".thm":"application/vnd.eri.thm" , ".tif":"image/tiff" , ".tiff":"image/tiff" , ".tki":"application/x-tkined" , ".tkined":"application/x-tkined" , ".toc":"application/toc" , ".toy":"image/toy" , ".tr":"application/x-troff" , ".trk":"x-lml/x-gps" , ".trm":"application/x-msterminal" , ".tsi":"audio/tsplayer" , ".tsp":"application/dsptype" , ".tsv":"text/tab-separated-values" , ".ttf":"application/octet-stream" , ".ttz":"application/t-time" , ".txt":"text/plain" , ".uls":"text/iuls" , ".ult":"audio/x-mod" , ".ustar":"application/x-ustar" , ".uu":"application/x-uuencode" , ".uue":"application/x-uuencode" , ".vcd":"application/x-cdlink" , ".vcf":"text/x-vcard" , ".vdo":"video/vdo" , ".vib":"audio/vib" , ".viv":"video/vivo" , ".vivo":"video/vivo" , ".vmd":"application/vocaltec-media-desc" , ".vmf":"application/vocaltec-media-file" , ".vmi":"application/x-dreamcast-vms-info" , ".vms":"application/x-dreamcast-vms" , ".vox":"audio/voxware" , ".vqe":"audio/x-twinvq-plugin" , ".vqf":"audio/x-twinvq" , ".vql":"audio/x-twinvq" , ".vre":"x-world/x-vream" , ".vrml":"x-world/x-vrml" , ".vrt":"x-world/x-vrt" , ".vrw":"x-world/x-vream" , ".vts":"workbook/formulaone" , ".wav":"audio/x-wav" , ".wax":"audio/x-ms-wax" , ".wbmp":"image/vnd.wap.wbmp" , ".wcm":"application/vnd.ms-works" , ".wdb":"application/vnd.ms-works" , ".web":"application/vnd.xara" , ".wi":"image/wavelet" , ".wis":"application/x-InstallShield" , ".wks":"application/vnd.ms-works" , ".wm":"video/x-ms-wm" , ".wma":"audio/x-ms-wma" , ".wmd":"application/x-ms-wmd" , ".wmf":"application/x-msmetafile" , ".wml":"text/vnd.wap.wml" , ".wmlc":"application/vnd.wap.wmlc" , ".wmls":"text/vnd.wap.wmlscript" , ".wmlsc":"application/vnd.wap.wmlscriptc" , ".wmlscript":"text/vnd.wap.wmlscript" , ".wmv":"audio/x-ms-wmv" , ".wmx":"video/x-ms-wmx" , ".wmz":"application/x-ms-wmz" , ".wpng":"image/x-up-wpng" , ".wps":"application/vnd.ms-works" , ".wpt":"x-lml/x-gps" , ".wri":"application/x-mswrite" , ".wrl":"x-world/x-vrml" , ".wrz":"x-world/x-vrml" , ".ws":"text/vnd.wap.wmlscript" , ".wsc":"application/vnd.wap.wmlscriptc" , ".wv":"video/wavelet" , ".wvx":"video/x-ms-wvx" , ".wxl":"application/x-wxl" , ".x-gzip":"application/x-gzip" , ".xaf":"x-world/x-vrml" , ".xar":"application/vnd.xara" , ".xbm":"image/x-xbitmap" , ".xdm":"application/x-xdma" , ".xdma":"application/x-xdma" , ".xdw":"application/vnd.fujixerox.docuworks" , ".xht":"application/xhtml+xml" , ".xhtm":"application/xhtml+xml" , ".xhtml":"application/xhtml+xml" , ".xla":"application/vnd.ms-excel" , ".xlc":"application/vnd.ms-excel" , ".xll":"application/x-excel" , ".xlm":"application/vnd.ms-excel" , ".xls":"application/vnd.ms-excel" , ".xlsx":"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" , ".xlt":"application/vnd.ms-excel" , ".xlw":"application/vnd.ms-excel" , ".xm":"audio/x-mod" , ".xml":"text/plain", ".xml":"application/xml", ".xmz":"audio/x-mod" , ".xof":"x-world/x-vrml" , ".xpi":"application/x-xpinstall" , ".xpm":"image/x-xpixmap" , ".xsit":"text/xml" , ".xsl":"text/xml" , ".xul":"text/xul" , ".xwd":"image/x-xwindowdump" , ".xyz":"chemical/x-pdb" , ".yz1":"application/x-yz1" , ".z":"application/x-compress" , ".zac":"application/x-zaurus-zac" , ".zip":"application/zip" , ".json":"application/json"&#125; 对 The First Project的主程序也做出了应的修改 1234567891011121314151617181920212223242526272829303132333435//http模块var http=require('http');//fs模块var fs=require('fs');//url模块var url=require("url");//自定义模块（设置文件格式）var model=require("./model/getmime.js");//path模块var path=require('path');http.createServer(function (request,respose) &#123; respose.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); var urlName=url.parse(request.url).pathname; if(urlName!='/favicon.ico')&#123;if(urlName=='/')&#123; urlName="/index.html";&#125; var extname=path.extname(urlName); fs.readFile('./static/'+urlName,function (err,date) &#123;if(err)&#123; fs.readFile('./static/404.html',function (error,date404) &#123; respose.writeHead(200,&#123;"Content-Type":"text/html;charset=UTF-8"&#125;); respose.write(date404); respose.end(); &#125;);return&#125;else &#123; var nime=model.getMime(fs,extname); respose.writeHead(200,&#123;"Content-Type":""+nime+";charset='utf-8'"&#125;); respose.write(date,"utf8"); respose.end();&#125;&#125;);&#125;&#125;).listen(80); Nodejs的单线程 非阻塞I/O事件驱动 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。 Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。 ###在NodeJS中大部分的API都是异步处理，如何解决异步处理的数据处理问题。 123456789101112var fs=require('fs');console.log("1");var datareturn=fs.readFile('./mime.json',function (err,data) &#123; if(err)&#123; console.log(err); return; &#125; console.log("2"); return data.toString();&#125;);console.log("3");console.log(datareturn); 运行结果 ​ 运行结果 原因分析：由于API中的fs.readFile()函数是异步操作，与主线程异步进行，所以导致数据回调不给主线程，导致数据无法获取。 修改（1）利用回调函数解决异步IO问题：123456789101112131415var fs=require('fs');console.log("1");function getDate(callback)&#123;fs.readFile('./mime.json',function (err,data) &#123; if(err)&#123; console.log(err); return; &#125; console.log("2");callback(data); //使用回调函数&#125;);&#125;getDate(function (data) &#123;//传入回调函数 console.log(data.toString()); console.log("3");&#125;); ###修改（2）利用时间驱动解决异步IO问题： 12345678910111213var fs=require('fs');var events=require('events');var EventEmitter=new events.EventEmitter();function getMime(callback)&#123; fs.readFile('mime.json',function(err,data)&#123; EventEmitter.emit('data',data) &#125;);&#125;getMime();/*执行方法*///监听广播数据EventEmitter.on('data',function(mime)&#123; console.log(mime.toString());&#125;); EJS模板使用ejs安装 安装代码 安装代码 npm install ejs –save cnpm install ejs –save ejs官方网站：https://ejs.bootcss.com/ 1234567891011121314151617//导入EJS模块var ejs =require('ejs');//导入HTTP模块var http=require('http');//导入URL模块var url=require('url');//创建server服务http.createServer(function (request,respose) &#123;//获取路径文件 var pathname=url.parse(request.url).pathname; if(pathname=="/")&#123; ejs.renderFile("./static/index.ejs", &#123; data:"这是后台数据"&#125;, function(err, str)&#123;respose.end(str);&#125;);&#125;&#125;).listen(80); &lt;% %&gt;流程控制标签 &lt;%= %&gt;输出标签（原文输出HTML标签） &lt;%- %&gt;输出标签（HTML会被浏览器解析） nodeJS的GET和POST数据获取get数据获取可以使用url模块（例子请查看上方）post数据获取123456789101112131415161718192021222324var ejs =require('ejs');var http=require('http');var url=require('url');http.createServer(function (request,respose) &#123; console.log(request.url); var pathname=url.parse(request.url).pathname; if(pathname=="/")&#123;ejs.renderFile("./static/index.ejs", &#123; data:"请输入账号密码"&#125;, function(err, str)&#123;respose.end(str);&#125;);&#125;if(pathname=="/login")&#123; var StringStr=""; /*post提交数据特征，数据段传输*/ request.on("data",function (str) &#123; StringStr+=str; &#125;); /*post提交数据结束特征*/ request.on("end",function () &#123; respose.end(StringStr); &#125;);&#125;&#125;).listen(80); 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%=data%&gt;&lt;/br&gt;&lt;form action="login" method="post"&gt; 账号：&lt;input type="text" name="username"/&gt;&lt;/br&gt; 密码：&lt;input type="password" name="password"/&gt; &lt;input type="submit" value="登录"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; #未完持续更新中]]></content>
      <categories>
        <category>前端全栈</category>
      </categories>
      <tags>
        <tag>NodeJs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC概述]]></title>
    <url>%2F2018%2F07%2F13%2Fssm%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[ssm框架概述 简介SSM（Spring+SpringMVC+MyBatis）框架集由Spring、SpringMVC、MyBatis三个开源框架整合而成，常作为数据源较简单的web项目的框架。 Spring一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架 SpringMVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制 MyBatis一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架 MVC设计思想表现层：html + css + jquery + ajax控制层：springmvc业务层：service组件持久层：dao组件 创建Maven工程 新建项目 img 选择Maven工程 img 勾选创建一个简单的工程 img 填写必要的内容关于 Group Id 和 Artifact Id 到底应该填什么，众说纷纭比较靠谱的说法是：Group Id 和 Artifact Id 被统称为“坐标”，是为了保证项目唯一性而提出的，如果你要把你项目弄到maven本地仓库去，你想要找到你的项目就必须根据这两个id去查找一般来讲，我们在 Group Id 栏填写域名的反写，Artifact Id 栏填写项目名我们要部署并运行项目，所以Packaging（打包方式）这边选择war包 img 解决报错问题（生成web.xml文件） img 指定tomcat运行 img img 导入 springMVC jar包 导包方式导包方式有2种：一种是eclipse直接选择或下载jar包，自动生成xml配置另一种是复制粘贴xml配置，自动下载jar包我们这边选择第一种，手动选择jar包，让它自动生成xml配置 jar版本jar版本根据实际需求酌情选择，这里只做演示用 选择导包界面 img spring-webmvc点击Add按钮，弹出窗口中搜索 spring-webmvc，选择图例中的jar包 img 这里以版本 3.2.8 为例 img 选择后，jar包就被添加进来了 img 切换到 pom.xml 选项卡，可以发现，jar包对应的xml配置已经自动生成了 img 保存配置选择jar包后，一定要按 Ctrl + S 对 pom.xml 文件进行保存然后 Maven 下就会自动添加jar包进去 img 导入 spring jar包 spring-jdbc用于事务控制 img img 导入 mybatis jar包 mybatis img]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（10）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%2F</url>
    <content type="text"><![CDATA[修改范例操作流程： 1.进入商品查询列表页面 2.点击修改，进入商品修改页面，页面中显示了要修改的商品。要修改的商品从数据库查询，根据商品id(主键)查询商品信息 3.在商品修改页面，修改商品信息，修改后，点击提交 开发mappermapper： 根据id查询商品信息 根据id更新Items表的数据 不用开发了，使用逆向工程生成的代码。 开发service在com.iot.learnssm.firstssm.service.ItemsService中添加两个接口 12345678910111213141516171819202122 //根据id查询商品信息 /** * * &lt;p&gt;Title: findItemsById&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param id 查询商品的id * @return * @throws Exception */ ItemsCustom findItemsById(Integer id) throws Exception; //修改商品信息 /** * * &lt;p&gt;Title: updateItems&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param id 修改商品的id * @param itemsCustom 修改的商品信息 * @throws Exception */ void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception;12345678910111213141516171819202122 在com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl中实现接口，增加itemsMapper属性 123456789101112131415161718192021222324@Autowiredprivate ItemsMapper itemsMapper;public ItemsCustom findItemsById(Integer id) throws Exception &#123; Items items = itemsMapper.selectByPrimaryKey(id); //中间对商品信息进行业务处理 //.... //返回ItemsCustom ItemsCustom itemsCustom = new ItemsCustom(); //将items的属性值拷贝到itemsCustom BeanUtils.copyProperties(items, itemsCustom); return itemsCustom;&#125;public void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception &#123; //添加业务校验，通常在service接口对关键参数进行校验 //校验 id是否为空，如果为空抛出异常 //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括 大文本类型字段 //updateByPrimaryKeyWithBLOBs要求必须转入id itemsCustom.setId(id); itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);&#125; 开发controller方法： ​ 商品信息修改页面显示 ​ 商品信息修改提交 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action//@RequestMapping("/items")public class ItemsController &#123; @Autowired private ItemsService itemsService; //商品查询列表 @RequestMapping("/queryItems") //实现 对queryItems方法和url进行映射，一个方法对应一个url //一般建议将url和方法写成一样 public ModelAndView queryItems() throws Exception&#123; //调用service查找数据库，查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList",itemsList); //指定视图 //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList //modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp"); //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀 modelAndView.setViewName("items/itemsList"); return modelAndView; &#125; //商品信息修改页面显示 @RequestMapping("/editItems") //限制http请求方法，可以post和get //@RequestMapping(value="/editItems",method=&#123;RequestMethod.POST, RequestMethod.GET&#125;) public ModelAndView editItems()throws Exception &#123; //调用service根据商品id查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(1); // 返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //将商品信息放到model modelAndView.addObject("itemsCustom", itemsCustom); //商品修改页面 modelAndView.setViewName("items/editItems"); return modelAndView; &#125; //商品信息修改提交 @RequestMapping("/editItemsSubmit") public ModelAndView editItemsSubmit(HttpServletRequest request, Integer id, ItemsCustom itemsCustom)throws Exception &#123; //调用service更新商品信息，页面需要将商品信息传到此方法 itemsService.updateItems(id, itemsCustom); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //返回一个成功页面 modelAndView.setViewName("success"); return modelAndView; &#125;&#125; @RequestMapping` url映射 定义controller方法对应的url，进行处理器映射使用。 窄化请求映射 123456//使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action@RequestMapping("/items")public class ItemsController &#123; 限制http请求方法 出于安全性考虑，对http的链接进行方法限制。 12345//商品信息修改页面显示 //@RequestMapping("/editItems") //限制http请求方法，可以post和get @RequestMapping(value="/editItems",method=&#123;RequestMethod.POST, RequestMethod.GET&#125;) public ModelAndView editItems()throws Exception &#123; 如果限制请求为post方法，进行get请求，即将上面代码的注解改为@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST}) 报错，状态码405： controller方法的返回值 返回ModelAndView 需要方法结束时，定义ModelAndView，将model和view分别进行设置。 返回string 如果controller方法返回string 1.表示返回逻辑视图名。 真正视图(jsp路径)=前缀+逻辑视图名+后缀 12345678910111213141516@RequestMapping(value="/editItems",method=&#123;RequestMethod.POST,RequestMethod.GET&#125;)//@RequestParam里边指定request传入参数名称和形参进行绑定。//通过required属性指定参数是否必须要传入//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。//public String editItems(Model model, @RequestParam(value="id",required=true) Integer items_id)throws Exception &#123;public String editItems(Model model)throws Exception &#123; //调用service根据商品id查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(1); //通过形参中的model将model数据传到页面 //相当于modelAndView.addObject方法 model.addAttribute("itemsCustom", itemsCustom); return "items/editItems";&#125; 2.redirect重定向 商品修改提交后，重定向到商品查询列表。 redirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享） 12//重定向到商品查询列表//return &quot;redirect:queryItems.action&quot;; 3.forward页面转发 通过forward进行页面转发，浏览器地址栏url不变，request可以共享。 12//页面转发return "forward:queryItems.action"; 返回void 在controller方法形参上可以定义request和response，使用request或response指定响应结果： 1.使用request转向页面，如下： request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response); 2.也可以通过response页面重定向： response.sendRedirect(&quot;url&quot;) 3.也可以通过response指定响应结果，例如响应json数据如下： 123response.setCharacterEncoding("utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().write("json串"); 注解开发之集合类型参数绑定本文主要介绍注解开发的集合类型参数绑定，包括数组绑定，list绑定以及map绑定 数组绑定需求商品批量删除，用户在页面选择多个商品，批量删除。 表现层实现关键：将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。 controller方法定义： 123// 批量删除 商品信息@RequestMapping("/deleteItems")public String deleteItems(Integer[] items_id) throws Exception 页面定义： 123456789101112&lt;c:forEach items="$&#123;itemsList &#125;" var="item"&gt;&lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" name="items_id" value="$&#123;item.id&#125;"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt; list绑定需求通常在需要批量提交数据时，将提交的数据绑定到list&lt;pojo&gt;中，比如：成绩录入（录入多门课成绩，批量提交）， 本例子需求：批量商品修改，在页面输入多个商品信息，将多个商品信息提交到controller方法中。 表现层实现 controller方法定义： 1、进入批量商品修改页面(页面样式参考商品列表实现) 2、批量修改商品提交 使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义list&lt;pojo&gt;属性 12345678910public class ItemsQueryVo &#123; //商品信息 private Items items; //为了系统 可扩展性，对原始生成的po进行扩展 private ItemsCustom itemsCustom; //批量商品信息 private List&lt;ItemsCustom&gt; itemsList; 1234567// 批量修改商品提交// 通过ItemsQueryVo接收批量提交的商品信息，将商品信息存储到itemsQueryVo中itemsList属性中。@RequestMapping("/editItemsAllSubmit")public String editItemsAllSubmit(ItemsQueryVo itemsQueryVo) throws Exception &#123; return "success";&#125; 页面定义： 12345678910&lt;c:forEach items="$&#123;itemsList &#125;" var="item" varStatus="status"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="itemsList[$&#123;status.index &#125;].name" value="$&#123;item.name &#125;"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="itemsList[$&#123;status.index &#125;].price" value="$&#123;item.price &#125;"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="itemsList[$&#123;status.index &#125;].createtime" value="&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="itemsList[$&#123;status.index &#125;].detail" value="$&#123;item.detail &#125;"/&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; name的格式： 对应包装pojo中的list类型属性名[下标(从0开始)].包装pojo中List类型的属性中pojo的属性名 例子： &quot;name=&quot;itemsList[${status.index }].price&quot; 可以和包装类型的参数绑定归纳对比一下，其实就是在包装类的pojo基础上多了个下标。只不过包装类参数绑定时，要和包装pojo中的pojo类性的属性名一致，而list参数绑定时，要和包装pojo中的list类型的属性名一致。 map绑定也通过在包装pojo中定义map类型属性。 在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。 包装类中定义Map对象如下： 1234Public class QueryVo &#123;private Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;(); //get/set方法..&#125; 页面定义如下： 12345678&lt;tr&gt;&lt;td&gt;学生信息：&lt;/td&gt;&lt;td&gt;姓名：&lt;inputtype="text"name="itemInfo['name']"/&gt;年龄：&lt;inputtype="text"name="itemInfo['price']"/&gt;.. .. ..&lt;/td&gt;&lt;/tr&gt; Contrller方法定义如下： 123public String useraddsubmit(Model model,QueryVo queryVo)throws Exception&#123;System.out.println(queryVo.getStudentinfo());&#125; springmvc校验本文主要介绍springmvc校验，包括环境准备，校验器配置，pojo张添加校验规则，捕获和显示检验错误信息以及分组校验简单示例。 校验理解项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。 服务端校验： 控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用） 业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。 持久层dao：一般是不校验的。 springmvc校验需求springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。 校验思路： 页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面。 具体需求： 商品修改，添加校验（校验商品名称长度，生产日期的非空校验），如果校验出错，在商品修改页面显示错误信息。 环境准备我们需要三个jar包： hibernate-validator.jar jboss-logging.jar validation-api.jar 这里我们添加maven依赖 123456&lt;!-- hibernate 校验 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.4.Final&lt;/version&gt;&lt;/dependency&gt; 可以看到，另外两个jar包被hibernate-validator依赖，所以不用再额外添加了。 配置校验器 在springmvc.xml中添加 12345678910111213141516171819202122&lt;!-- 校验器 --&gt;&lt;bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"&gt; &lt;!-- hibernate校验器--&gt; &lt;property name="providerClass" value="org.hibernate.validator.HibernateValidator" /&gt; &lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties --&gt; &lt;property name="validationMessageSource" ref="messageSource" /&gt;&lt;/bean&gt;&lt;!-- 校验错误信息配置文件 --&gt;&lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt; &lt;!-- 资源文件名--&gt; &lt;property name="basenames"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomValidationMessages&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name="fileEncodings" value="utf-8" /&gt; &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt; &lt;property name="cacheSeconds" value="120" /&gt;&lt;/bean&gt; 校验器注入到处理器适配器中 12&lt;mvc:annotation-driven conversion-service="conversionService" validator="validator"&gt;&lt;/mvc:annotation-driven&gt; 在CustomValidationMessages.properties配置校验错误信息： 123#添加校验的错误提示信息items.name.length.error=请输入1到30个字符的商品名称items.createtime.isNUll=请输入商品的生产日期 在pojo中添加校验规则在ItemsCustom.java中添加校验规则： 123456789101112131415public class Items &#123; private Integer id; //校验名称在1到30字符中间 //message是提示校验出错显示的信息 //groups：此校验属于哪个分组，groups可以定义多个分组 @Size(min=1,max=30,message="&#123;items.name.length.error&#125;") private String name; private Float price; private String pic; //非空校验 @NotNull(message="&#123;items.createtime.isNUll&#125;") private Date createtime; 捕获和显示校验错误信息1234567@RequestMapping("/editItemsSubmit")public String editItemsSubmit( Model model, HttpServletRequest request, Integer id, @Validated ItemsCustom itemsCustom, BindingResult bindingResult)throws Exception &#123; 在controller中将错误信息传到页面即可 123456789101112131415161718//获取校验错误信息if(bindingResult.hasErrors())&#123; // 输出错误信息 List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors(); for (ObjectError objectError :allErrors)&#123; // 输出错误信息 System.out.println(objectError.getDefaultMessage()); &#125; // 将错误信息传到页面 model.addAttribute("allErrors", allErrors); //可以直接使用model将提交pojo回显到页面 model.addAttribute("items", itemsCustom); // 出错重新到商品修改页面 return "items/editItems";&#125; 页面显示错误信息： 123456&lt;!-- 显示错误信息 --&gt;&lt;c:if test="$&#123;allErrors!=null &#125;"&gt; &lt;c:forEach items="$&#123;allErrors &#125;" var="error"&gt; $&#123; error.defaultMessage&#125;&lt;br/&gt; &lt;/c:forEach&gt;&lt;/c:if&gt; 分组校验 需求： 在pojo中定义校验规则，而pojo是被多个controller所共用，当不同的controller方法对同一个pojo进行校验，但是每个controller方法需要不同的校验 解决方法： 定义多个校验分组（其实是一个java接口），分组中定义有哪些规则 每个controller方法使用不同的校验分组 1.校验分组 12345public interface ValidGroup1 &#123; //接口中不需要定义任何方法，仅是对不同的校验规则进行分组 //此分组只校验商品名称长度&#125; 2.在校验规则中添加分组 12345//校验名称在1到30字符中间//message是提示校验出错显示的信息//groups：此校验属于哪个分组，groups可以定义多个分组@Size(min=1,max=30,message="&#123;items.name.length.error&#125;",groups = &#123;ValidGroup1.class&#125;)private String name; 3.在controller方法使用指定分组的校验 12345678// value=&#123;ValidGroup1.class&#125;指定使用ValidGroup1分组的校验@RequestMapping("/editItemsSubmit")public String editItemsSubmit( Model model, HttpServletRequest request, Integer id, @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom, BindingResult bindingResult)throws Exception &#123; 数据回显本文介绍springmvc中数据回显的几种实现方法 数据回显：提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。 pojo数据回显方法1.springmvc默认对pojo数据进行回显。 pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写） 使用@ModelAttribute指定pojo回显到页面在request中的key 2.@ModelAttribute还可以将方法的返回值传到页面 在商品查询列表页面，通过商品类型查询商品信息。在controller中定义商品类型查询方法，最终将商品类型传到页面。 1234567891011 // 商品分类//itemtypes表示最终将方法返回值放在request中的key@ModelAttribute(&quot;itemtypes&quot;)public Map&lt;String, String&gt; getItemTypes() &#123; Map&lt;String, String&gt; itemTypes = new HashMap&lt;String, String&gt;(); itemTypes.put(&quot;101&quot;, &quot;数码&quot;); itemTypes.put(&quot;102&quot;, &quot;母婴&quot;); return itemTypes;&#125; 页面上可以得到itemTypes数据。 123456789&lt;td&gt; 商品名称：&lt;input name=&quot;itemsCustom.name&quot; /&gt; 商品类型： &lt;select name=&quot;itemtype&quot;&gt; &lt;c:forEach items=&quot;$&#123;itemtypes&#125;&quot; var=&quot;itemtype&quot;&gt; &lt;option value=&quot;$&#123;itemtype.key &#125;&quot;&gt;$&#123;itemtype.value &#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/td&gt; 3.使用最简单方法使用model，可以不用@ModelAttribute 12//可以直接使用model将提交pojo回显到页面//model.addAttribute(&quot;items&quot;, itemsCustom); 简单类型数据回显使用最简单方法使用model model.addAttribute(&quot;id&quot;, id); 异常处理器本文主要介绍springmvc中异常处理的思路，并展示如何自定义异常处理类以及全局异常处理器的配置 异常处理思路系统中异常包括两类： 预期异常 运行时异常RuntimeException 前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图： 自定义异常类对不同的异常类型定义异常类，继承Exception。 123456789101112131415161718192021222324package com.iot.learnssm.firstssm.exception;/** * Created by brian on 2016/3/7. * * 系统 自定义异常类，针对预期的异常，需要在程序中抛出此类的异常 */public class CustomException extends Exception&#123; //异常信息 public String message; public CustomException(String message)&#123; super(message); this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 全局异常处理器思路： 系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。 全局异常处理器处理思路： 解析出异常类型 如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示 如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（信息为“未知错误”） springmvc提供一个HandlerExceptionResolver接口 1234567891011121314151617181920212223242526272829303132333435 public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //handler就是处理器适配器要执行Handler对象（只有method） //解析出异常类型 //如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示 //String message = null; //if(ex instanceof CustomException)&#123; //message = ((CustomException)ex).getMessage(); //&#125;else&#123; ////如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”） //message="未知错误"; //&#125; //上边代码变为 CustomException customException; if(ex instanceof CustomException)&#123; customException = (CustomException)ex; &#125;else&#123; customException = new CustomException("未知错误"); &#125; //错误信息 String message = customException.getMessage(); ModelAndView modelAndView = new ModelAndView(); //将错误信息传到页面 modelAndView.addObject("message", message); //指向错误页面 modelAndView.setViewName("error"); return modelAndView; &#125;&#125; 错误页面12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: Brian Date: 2016/3/4 Time: 10:51 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误提示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 在springmvc.xml配置全局异常处理器1234&lt;!-- 全局异常处理器只要实现HandlerExceptionResolver接口就是全局异常处理器--&gt;&lt;bean class="com.iot.learnssm.firstssm.exception.CustomExceptionResolver"&gt;&lt;/bean&gt; 全局异常处理器只有一个，配置多个也没用。 异常测试在controller、service、dao中任意一处需要手动抛出异常。如果是程序中手动抛出的异常，在错误页面中显示自定义的异常信息，如果不是手动抛出异常说明是一个运行时异常，在错误页面只显示“未知错误”。 在商品修改的controller方法中抛出异常 . 12345678910111213141516public String editItems(Model model,@RequestParam(value="id",required=true) Integer items_id)throws Exception &#123; //调用service根据商品id查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(items_id); //判断商品是否为空，根据id没有查询到商品，抛出异常，提示用户商品信息不存在 if(itemsCustom == null)&#123; throw new CustomException("修改的商品信息不存在!"); &#125; //通过形参中的model将model数据传到页面 //相当于modelAndView.addObject方法 model.addAttribute("items", itemsCustom); return "items/editItems";&#125; 在service接口中抛出异常： 1234567891011121314151617public ItemsCustom findItemsById(Integer id) throws Exception &#123; Items items = itemsMapper.selectByPrimaryKey(id); if(items==null)&#123; throw new CustomException("修改的商品信息不存在!"); &#125; //中间对商品信息进行业务处理 //.... //返回ItemsCustom ItemsCustom itemsCustom = null; //将items的属性值拷贝到itemsCustom if(items!=null)&#123; itemsCustom = new ItemsCustom(); BeanUtils.copyProperties(items, itemsCustom); &#125; return itemsCustom;&#125; 如果与业务功能相关的异常，建议在service中抛出异常。 与业务功能没有关系的异常，建议在controller中抛出。 上传图片在修改商品页面，添加上传商品图片功能。 在页面form中提交enctype=&quot;multipart/form-data&quot;的数据时，需要springmvc对multipart类型的数据进行解析。 在springmvc.xml中配置multipart类型解析器。 12345678&lt;!-- 文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为5MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 加入上传图片的jar添加依赖 123456&lt;!-- 文件上传 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 依赖树 12[INFO] \- commons-fileupload:commons-fileupload:jar:1.3.1:compile[INFO] \- commons-io:commons-io:jar:2.2:compile12 可以看到，其实还间接依赖了commons-io:commons-io:jar 创建图片虚拟目录存储图片IDEA我使用的版本为 tomcat 8.0.30 intellij 15.0.2 jdk 1.8.0_25 已经部署好了一个web应用，并且已经在IDEA中添加好了tomcat容器，现在想为这个web应用添加一个图片虚拟目录 1.点击工具栏的运行配置Edit Configurations 2.在弹出的Run/debug Configurations中选中tomcat容器，选择deployment这个tab 3.添加物理目录和并设置虚拟目录路径 这里我选择了D盘下面的tmp文件夹作为物理目录，虚拟目录设为了/pic,我试了下，虽然斜杠少了也没什么影响，一样能访问，不过还是建议加上吧。 4.运行web应用，访问图片资源这里需要接上具体访问资源的文件名，不然后访问不到的，如下图 tomcat配置虚拟目录映射一、在Server.xml中进行配置在元素中添加子元素 并重启服务器即可； path表示虚拟目录，docBase表示真实的web应用所在目录； 比如在C盘中存在a这个web应用,则 则输入 http://localhost:8888/test/1.html 就能访问到a文件夹下的 1.html 注意：这种方法需要重启服务器才能够生效，所以不适用，因为每次添加一个web应用都需要重启服务器。 二、最佳配置方法$CATALINA_BASE/conf/catalina/localhost/ 文件夹下创建一个xml文件，任意文件名都可以，但是此文件名是web应用发布后的虚拟目录； 比如创建一个test.xml ，在文件中添加 &lt;Context docBase=&quot;C:\a&quot;/&gt; 不需要重启服务器，只需要在浏览器中输入 http://localhost:8888/test/1.html 即可访问C:\a\1.html ； 三、配置默认web应用一般，输入 http://localhost:8080 后都会跳出 tomcat的主页，因为这个tomcat的web应用就是默认的web应用，如果想将自己的web应用配置成默认的web应用，只需要在Server.xml中的元素中为 或者将test.xml改成 ROOT.xml 即可； 输入 http://localhost:8080/1.html 就能访问C:\a\1.html ; 注意：在图片虚拟目录中，一定将图片目录分级创建（提高i/o性能），一般我们采用按日期(年、月、日)进行分级创建。 上传图片代码12345678910&lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt; &lt;c:if test="$&#123;items.pic !=null&#125;"&gt; &lt;img src="/pic/$&#123;items.pic&#125;" width=100 height=100/&gt; &lt;br/&gt; &lt;/c:if&gt; &lt;input type="file" name="items_pic"/&gt; &lt;/td&gt;&lt;/tr&gt; controller方法 修改：商品修改controller方法： 12345678910111213141516171819202122232425262728293031@RequestMapping("/editItemsSubmit") public String editItemsSubmit( Model model, HttpServletRequest request, Integer id, @ModelAttribute("items") @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom, BindingResult bindingResult, MultipartFile items_pic )throws Exception &#123;12345678910 //原始名称String originalFilename = items_pic.getOriginalFilename();//上传图片if(items_pic!=null &amp;&amp; originalFilename!=null &amp;&amp; originalFilename.length()&gt;0)&#123; //存储图片的物理路径 String pic_path = "D:\\tmp\\"; //新的图片名称 String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(".")); //新图片 File newFile = new File(pic_path+newFileName); //将内存中的数据写入磁盘 items_pic.transferTo(newFile); //将新图片名称写到itemsCustom中 itemsCustom.setPic(newFileName);&#125; json数据交互本文主要介绍如何在springmvc中进行json数据的交互，先是环境准备和配置，然后分别展示了“输入json串，输出是json串”和“输入key/value，输出是json串”两种情况下的交互 springmvc进行json交互json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。 比如：webservice接口，传输json数据. 请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。 请求key/value、输出json。此方法比较常用。 环境准备添加json转换的依赖最开始我少了jackson-databind依赖，程序各种报错。 123456789101112&lt;!-- json 转换--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt; 依赖树 12345[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.7.2:compile[INFO] | +- com.fasterxml.jackson.core:jackson-annotations:jar:2.7.0:compile[INFO] | \- com.fasterxml.jackson.core:jackson-core:jar:2.7.2:compile[INFO] \- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile[INFO] \- org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile 配置json转换器在注解适配器中加入messageConverters 12345678&lt;!--注解适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 注意：如果使用&lt;mvc:annotation-driven /&gt;则不用定义上边的内容。 json交互测试显示两个按钮分别测试 jsp页面 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: brian Date: 2016/3/7 Time: 20:49 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;json交互测试&lt;/title&gt; &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath &#125;/js/jquery-1.4.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //请求json，输出是json function requestJson()&#123; 省略 &#125; //请求key/value，输出是json function responseJson()&#123; 省略 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" onclick="requestJson()" value="请求json，输出是json"/&gt;&lt;input type="button" onclick="responseJson()" value="请求key/value，输出是json"/&gt;&lt;/body&gt; controller 1234@Controllerpublic class JsonTest &#123; 省略&#125; 测试结果 输入json串，输出是json串使用jquery的ajax提交json串，对输出的json结果进行解析。 jsp页面 12345678910111213141516//请求json，输出是jsonfunction requestJson()&#123; $.ajax(&#123; type:'post', url:'$&#123;pageContext.request.contextPath &#125;/requestJson.action', contentType:'application/json;charset=utf-8', //数据格式是json串，商品信息 data:'&#123;"name":"手机","price":999&#125;', success:function(data)&#123;//返回json结果 alert(data); &#125; &#125;);&#125; controller 123456789 //请求json串(商品信息)，输出json(商品信息)//@RequestBody将请求的商品信息的json串转成itemsCustom对象//@ResponseBody将itemsCustom转成json输出@RequestMapping("/requestJson")public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom)&#123; //@ResponseBody将itemsCustom转成json输出 return itemsCustom;&#125; 可以看到，request和response的HTTP头的Content-Type都是application/json;charset=utf-8 请求json，返回json,response的body 输入key/value，输出是json串使用jquery的ajax提交key/value串，对输出的json结果进行解析 jsp页面 1234567891011121314151617//请求key/value，输出是jsonfunction responseJson()&#123; $.ajax(&#123; type:'post', url:'$&#123;pageContext.request.contextPath &#125;/responseJson.action', //请求是key/value这里不需要指定contentType，因为默认就 是key/value类型 //contentType:'application/json;charset=utf-8', //数据格式是json串，商品信息 data:'name=手机&amp;price=999', success:function(data)&#123;//返回json结果 alert(data.name); &#125; &#125;);&#125; controller 1234567 //请求key/value，输出json@RequestMapping("/responseJson")public @ResponseBody ItemsCustom responseJson(ItemsCustom itemsCustom)&#123; //@ResponseBody将itemsCustom转成json输出 return itemsCustom;&#125; 可以看到，key/value键值对的默认Content-Type是application/x-www-form-urlencoded,同时，我们收到了响应“手机”]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（6）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[入门程序配置小结通过入门程序理解springmvc前端控制器、处理器映射器、处理器适配器、视图解析器用法。并附上入门程序的非注解的完整的配置文件，注解的完整配置文件。 前端控制器配置： 第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析 第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析,使用此种方式可以实现RESTful风格的url 处理器映射器： 非注解处理器映射器（了解） 注解的处理器映射器（掌握） 对标记@Controller类中标识有@RequestMapping的方法进行映射。在@RequestMapping里边定义映射的url。使用注解的映射器不用在xml中配置url和Handler的映射关系。 处理器适配器：非注解处理器适配器（了解）注解的处理器适配器（掌握）注解处理器适配器和注解的处理器映射器是配对使用。理解为不能使用非注解映射器进行映射。 1&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 可以代替下边的配置： 1234&lt;!--注解映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt; &lt;!--注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; 非注解的完整的配置文件文件：src/main/resources/springmvc.xml 123456789101112131415161718192021222324252627&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置Handler --&gt; &lt;bean name="/queryItems.action" class="com.iot.ssm.controller.ItemsController"/&gt; &lt;!-- 处理器映射器 将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url) --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt; &lt;!-- 处理器适配器 所有处理器适配器都实现了HandlerAdapter接口 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/&gt; &lt;!-- 视图解析器 解析jsp,默认使用jstl,classpath下要有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"/&gt;&lt;/beans&gt; 注解的完整的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 对于注解的Handler 可以单个配置 实际开发中加你使用组件扫描 --&gt; &lt;!-- &lt;bean class="com.iot.ssm.controller.ItemsController3"/&gt; --&gt; &lt;!-- 可以扫描controller、service、... 这里让扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package="com.iot.ssm.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 注解的映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt; &lt;!-- 注解的适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 视图解析器 解析jsp,默认使用jstl,classpath下要有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（4）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注解的处理器映射器和适配器版本配置在spring3.1之前使用 org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping注解映射器。 在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器。 在spring3.1之前使用 org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter注解适配器。 在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器 映射器和适配器的配置1234&lt;!-- 注解的映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;&lt;!-- 注解的适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; 123456&lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 开发注解Handler使用注解的映射器和注解的适配器。(使用注解的映射器和注解的适配器必须配对使用) 12345678910111213141516171819202122232425262728293031//使用@Controller来标识它是一个控制器@Controllerpublic class ItemsController3 &#123; //商品查询列表 @RequestMapping("/queryItems") //实现 对queryItems方法和url进行映射，一个方法对应一个url //一般建议将url和方法写成一样 public ModelAndView queryItems() throws Exception&#123; //调用service查找数据库，查询商品列表，这里使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 c3 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList",itemsList); //指定视图 modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp"); return modelAndView; &#125;&#125; 在spring容器中加载Handler1234&lt;!-- 对于注解的Handler可以单个配置实际开发中加你使用组件扫描--&gt; &lt;!-- &lt;bean class="com.iot.ssm.controller.ItemsController3"/&gt; --&gt; &lt;!-- 可以扫描controller、service、...这里让扫描controller，指定controller的包--&gt; &lt;context:component-scan base-package="com.iot.ssm.controller"&gt;&lt;/context:component-scan&gt; ##]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（1）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringMVC操作笔记SpringMVC基础知识介绍###SpringMVC功能部件 组件及其作用 前端控制器(DispatcherServlet)：接收请求，响应结果，相当于转发器，中央处理器。减少了其他组件之间的耦合度 处理器映射器(HandlerMapping)：根据请求的url查找Handler Handler处理器：按照HandlerAdapter的要求编写 处理器适配器(HandlerAdapter)：按照特定规则(HandlerAdapter要求的规则)执行Handler。 视图解析器(ViewResolver)：进行视图解析，根据逻辑视图解析成真正的视图(View) 视图(View)：View是一个接口实现类试吃不同的View类型（jsp,pdf等等） Spring工作流程 1.发起请求到前端控制器(DispatcherServlet) 2.前端控制器请求处理器映射器(HandlerMapping)查找Handler(可根据xml配置、注解进行查找) 3.处理器映射器(HandlerMapping)向前端控制器返回Handler 4.前端控制器调用处理器适配器(HandlerAdapter)执行Handler 5.处理器适配器(HandlerAdapter)去执行Handler 6.Handler执行完，给适配器返回ModelAndView(Springmvc框架的一个底层对象) 7.处理器适配器(HandlerAdapter)向前端控制器返回ModelAndView 8.前端控制器(DispatcherServlet)请求视图解析器(ViewResolver)进行视图解析，根据逻辑视图名解析成真正的视图(jsp) 9.视图解析器(ViewResolver)向前端控制器(DispatcherServlet)返回View 10.前端控制器进行视图渲染，即将模型数据(在ModelAndView对象中)填充到request域 11.前端控制器向用户响应结果]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（2）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringMVC(MAVEN工程创建)IDEA创建过程①创建MAVEN（web工程）new-&gt;project-&gt;maven，建一个裸的maven工程 ②添加依赖（pom.xml文件）123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;!--版本号4.2.4--&gt;&lt;/dependency&gt; ③配置文件–前端控制器（web.xml）123456789101112&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等) 若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml) --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;!--Springmvc.xml文件的地址--&gt; &lt;/init-param&gt;&lt;/servlet&gt; 1234567891011&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析 第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析， 使用此种方式和实现RESTful风格的url 第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址， 不能根据jsp页面找到handler，会报错 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置后的web.xml ⑤配置Handler将编写Handler在spring容器加载 12&lt;!-- 配置Handler --&gt;&lt;bean name="/queryItems.action" class="com.iot.ssm.controller.ItemsController"/&gt; ⑥配置处理器映射器在classpath下的springmvc.xml中配置处理器映射器 1234&lt;!-- 处理器映射器 将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)--&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt; ⑦配置处理器适配器所有处理器适配器都实现了HandlerAdapter接口 &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt; 源码 123public boolean supports(Object handler) &#123; return handler instanceof Controller;&#125; 此适配器能执行实现Controller接口的Handler ⑧配置视图解析器需要配置解析jsp的视图解析器 1234&lt;!-- 视图解析器 解析jsp,默认使用jstl,classpath下要有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"/&gt; 在springmvc.xml中视图解析器配置前缀和后缀： 123456&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; 程序中不用指定前缀和后缀： 123456//指定视图//下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList//modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp");//下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀modelAndView.setViewName("items/itemsList"); 部署调试HTTP Status 404 -处理器映射器根据url找不到Handler,说明url错误 HTTP Status 404 -/springmvc/WEB-INF/jsp/items/itemsLists.jsp处理器映射器根据url找到了Handler，转发的jsp页面找不到]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（7）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[springmvc整合mybatis(IDEA中通过maven构建)构建思路 第一步：整合dao层 mybatis和spring整合，通过spring管理mapper接口。 使用mapper的扫描器自动扫描mapper接口在spring中进行注册。 第二步：整合service层 通过spring管理service接口。 使用配置方式将service接口配置在spring配置文件中。 实现事务控制。 第三步：整合springmvc 由于springmvc是spring的模块，不需要整合。 不同于spring和mybatis整合中的示例demo,本文的整合采用maven构建。 new-&gt;project-&gt;maven，建一个裸的maven工程，手动建webapp的目录 在src/main下新建文件夹webapp 添加依赖pom.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.iot.learnssm&lt;/groupId&gt; &lt;artifactId&gt;learnssm-firstssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- jar 版本设置 --&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP tag --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 这里添加的依赖可能有多的,但总比少包好，我开始就是引少了依赖(springframework的依赖只引用了spring-mvc,连spring-core都没引)，导致报错,以后会出一篇博客专门讲这个系列笔记中debug相关问题。 建包在java目录下建各个package,按照maven的明明习惯: com.公司名.项目名.模块名 这里我的包为： com.iot.learnssm.firstssm 包含几个子包： controller mapper po service impl 项目结构如图：]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（8）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%2F</url>
    <content type="text"><![CDATA[整合dao首先在resource文件夹下添加两个文件：数据库配置文件和日志配置文件 数据库配置文件db.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8jdbc.username=rootjdbc.password=1231234 日志配置文件log4j.properties 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n sqlMapConfig.xmlmybatis自己的配置文件 在resources目录下新建mybatis文件夹，并新建sqlMapConfig.xml文件 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 全局setting配置，根据需要添加 --&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量扫描别名 --&gt; &lt;package name="com.iot.learnssm.firstssm.po"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置mapper 由于使用spring和mybatis的整合包进行mapper扫描，这里不需要配置了。 必须遵循：mapper.xml和mapper.java文件同名且在一个目录 --&gt; &lt;!-- &lt;mappers&gt; &lt;/mappers&gt; --&gt;&lt;/configuration&gt; applicationContext-dao.xml在resources目录下新建spring文件夹，并新建applicationContext-dao.xml文件 配置： 数据源 SqlSessionFactory mapper扫描器 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 加载db.properties文件中的内容，db.properties文件中key命名要有一定的特殊规则 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置数据源 ，dbcp --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="30" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- 从整合包里找，org.mybatis:mybatis-spring:1.2.4 --&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/sqlMapConfig.xml" /&gt; &lt;/bean&gt; &lt;!-- mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 --&gt; &lt;property name="basePackage" value="com.iot.learnssm.firstssm.mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt; 会导致数据源配置不管用，数据库连接不上。 且spring 4弃用 --&gt; &lt;/bean&gt;&lt;/beans&gt; 逆向工程生成po类及mapper(单表增删改查)手动定义商品查询mapper针对综合查询mapper，一般情况会有关联查询，建议自定义mapper ItemsMapperCustom.xml 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.iot.learnssm.firstssm.mapper.ItemsMapperCustom" &gt; &lt;!-- 定义商品查询的sql片段，就是商品查询条件 --&gt; &lt;sql id="query_items_where"&gt; &lt;!-- 使用动态sql，通过if判断，满足条件进行sql拼接 --&gt; &lt;!-- 商品查询条件通过ItemsQueryVo包装对象 中itemsCustom属性传递 --&gt; &lt;if test="itemsCustom!=null"&gt; &lt;if test="itemsCustom.name!=null and itemsCustom.name!=''"&gt; items.name LIKE '%$&#123;itemsCustom.name&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; &lt;!-- 商品列表查询 --&gt; &lt;!-- parameterType传入包装对象(包装了查询条件) resultType建议使用扩展对象 --&gt; &lt;select id="findItemsList" parameterType="com.iot.learnssm.firstssm.po.ItemsQueryVo" resultType="com.iot.learnssm.firstssm.po.ItemsCustom"&gt; SELECT items.* FROM items &lt;where&gt; &lt;include refid="query_items_where"&gt;&lt;/include&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; ItemsMapperCustom.java 1234public interface ItemsMapperCustom &#123; //商品查询列表 List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo)throws Exception;&#125; po类ItemsCustom 123456789package com.iot.learnssm.firstssm.po;/** * Created by Brian on 2016/3/2. * 商品信息的扩展类 */public class ItemsCustom extends Items&#123; //添加商品信息的扩展属性&#125; 输入pojo的包装类 1234567891011121314151617181920212223242526272829package com.iot.learnssm.firstssm.po;/** * Created by Brian on 2016/3/2. */public class ItemsQueryVo &#123; //商品信息 private Items items; //为了系统 可扩展性，对原始生成的po进行扩展 private ItemsCustom itemsCustom; public Items getItems() &#123; return items; &#125; public void setItems(Items items) &#123; this.items = items; &#125; public ItemsCustom getItemsCustom() &#123; return itemsCustom; &#125; public void setItemsCustom(ItemsCustom itemsCustom) &#123; this.itemsCustom = itemsCustom; &#125;&#125; 整合好dao后的工程目录如图]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（9）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%2F</url>
    <content type="text"><![CDATA[定义service接口12345public interface ItemsService &#123; //商品查询列表 List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;&#125; 123456789public class ItemsServiceImpl implements ItemsService &#123; @Autowired private ItemsMapperCustom itemsMapperCustom; public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception &#123; return itemsMapperCustom.findItemsList(itemsQueryVo); &#125;&#125; 在spring容器配置service在resources/spring下创建applicationContext-service.xml，文件中配置service。 12345678&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"&gt; &lt;!-- 商品管理的service --&gt; &lt;bean id="itemsService" class="com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl"/&gt;&lt;/beans&gt; 事务控制在resources/spring下创建applicationContext-transaction.xml，在applicationContext-transaction.xml中使用spring声明式事务控制方法。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;!-- 事务管理器 对mybatis操作数据库事务控制，spring使用jdbc的事务控制类 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 dataSource在applicationContext-dao.xml中配置了 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="insert*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.iot.learnssm.firstssm.service.impl.*.*(..))"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 定义controllerspringmvc.xml在resources/spring文件下下创建springmvc.xml文件，配置处理器映射器、适配器、视图解析器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 对于注解的Handler 可以单个配置 实际开发中加你使用组件扫描 --&gt; &lt;!-- 可以扫描controller、service、... 这里让扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package="com.iot.learnssm.firstssm.controller"&gt;/context:component-scan &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 视图解析器 解析jsp,默认使用jstl,classpath下要有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;firstssm&lt;/display-name&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;!-- &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;--&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- springmvc 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等) 若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml) --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 第一种:*.action,访问以.action三结尾，由DispatcherServlet进行解析 第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析， 使用此种方式和实现RESTful风格的url 第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址， 不能根据jsp页面找到handler，会报错 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 这个文件有两个作用： 配置前端控制器(DispatcherServlet) 加载spring容器：添加spring容器监听器，加载spring容器，使用通配符加载spring/ 下的配置文件： applicationContext-dao.xml applicationContext-service.xml applicationContext-transaction.xml 编写Controller(就是Handler)123456789101112131415161718192021222324252627282930313233343536373839package com.iot.learnssm.firstssm.controller;import com.iot.learnssm.firstssm.po.Items;import com.iot.learnssm.firstssm.po.ItemsCustom;import com.iot.learnssm.firstssm.service.ItemsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;/** * Created by brian on 2016/3/2. *///使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.actionpublic class ItemsController &#123; @Autowired private ItemsService itemsService; //商品查询列表 @RequestMapping("/queryItems") //实现 对queryItems方法和url进行映射，一个方法对应一个url //一般建议将url和方法写成一样 public ModelAndView queryItems() throws Exception&#123; //调用service查找数据库，查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList",itemsList); //指定视图 //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList //modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp"); //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀 modelAndView.setViewName("items/itemsList"); return modelAndView; &#125;&#125; 编写jsp服务器路径为WEB-INF/jsp/items/itemsList.jsp 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/item/queryItem.action" method="post"&gt;查询条件：&lt;table width="100%" border=1&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;商品列表：&lt;table width="100%" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items="$&#123;itemsList &#125;" var="item"&gt;&lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/item/editItem.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ##]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（3）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[非注解的处理器映射器和适配器非注解的处理器映射器123456789101112131415161718&lt;!-- 配置Handler --&gt;&lt;bean id="itemsController" name="/queryItems.action" class="com.iot.ssm.controller.ItemsController"/&gt;&lt;!-- 处理器映射器将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url) --&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;&lt;!-- 简单url映射--&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;!-- 对 itemsController进行url映射--&gt; &lt;prop key="/queryItems1.action"&gt;itemsController&lt;/prop&gt; &lt;prop key="/queryItems2.action"&gt;itemsController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; $$多个映射器可并存，前端控制器判断url能让哪些映射器处理就让正确的映射器处理$$ 非注解的处理器适配器1234&lt;!-- 处理器适配器 所有处理器适配器都实现了HandlerAdapter接口 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/&gt; 1234567891011121314151617181920212223242526272829303132333435public class ItemsController1 implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //调用service查找 数据库，查询商品列表，这里使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当 于request的setAttribut，在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList", itemsList); //指定视图 modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp"); return modelAndView; &#125;&#125; 要求编写的Handler实现Controller接口 &lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt; 要求编写的Handler实现HttpRequestHandler接口 123456789101112131415161718192021222324252627282930313233343536373839404142package com.iot.ssm.controller;import com.iot.ssm.po.Items;import org.springframework.web.HttpRequestHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Created by brian on 2016/2/19. */public class ItemsController2 implements HttpRequestHandler&#123; public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; //调用service查找数据库，查询商品列表，这里使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); //设置模型数据 httpServletRequest.setAttribute("itemsList",itemsList); //设置转发的视图 httpServletRequest.getRequestDispatcher("/WEB-INF/jsp/items/itemsList.jsp").forward(httpServletRequest,httpServletResponse); &#125;&#125; HttpRequestHandler适配器的handleRequest方法返回为void,没有返回ModelAndView，可通过response修改响应内容,比如返回json数据： 123response.setCharacterEncoding("utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().write("json串"); springmvc的默认加载 前端控制器从上边的文件中加载处理映射器、适配器、视图解析器等组件，如果不在springmvc.xml‘‘’中配置，使用默认加载的。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记（5）]]></title>
    <url>%2F2018%2F07%2F12%2FSpringMVC%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端控制器1.前端控制器接收请求 调用doDispatch方法 12345protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false;&#125; 2.前端控制器调用HandlerMapping（处理器映射器）根据url查找Handler 12// Determine handler for the current request.mappedHandler = getHandler(processedRequest); 1234567891011121314151617181920/**- Return the HandlerExecutionChain for this request.- &lt;p&gt;Tries all handler mappings in order.- @param request current HTTP request- @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found **/ protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( "Testing handler map [" + hm + "] in DispatcherServlet with name '" + getServletName() + "'"); &#125; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null; &#125; 3.调用处理器适配器执行Handler,得到执行的结果ModelAndView mv 在doDispatch方法中 12// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 4.视图渲染，将model数据填充到request域 doDispatch-&gt;processDispatchResult-&gt;render 在render方法中,视图解析得到view 123// We need to resolve the view name.view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);123 5.调用view的渲染方法，将model数据填充到request域 在render方法中,调用View接口的render方法 1view.render(mv.getModelInternal(), request, response); ##]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringMVC笔记</tag>
      </tags>
  </entry>
</search>
